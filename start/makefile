CC = g++
CFLAGS = -Wall -g
LDLIBS = -lglut -lGLU -lGL 

BUILD_DIR = build
MKDIR_P = mkdir -p

# 定义所有要生成可执行文件的源文件
# 修正：你需要显式列出文件名，或者使用 shell 命令 find/ls 来获取列表。
# 假设源文件是 app1.c 和 app2.cpp
EXEC_SRCS = start.cpp

# 定义最终要生成的所有的可执行文件列表 (去掉 .c 或 .cpp 后缀)
TARGETS = $(EXEC_SRCS:.c=) $(EXEC_SRCS:.cpp=)

# 默认目标：编译所有可执行文件
# 修正：移除了 MKDIR_P 作为依赖，现在只依赖于最终的可执行文件。
all: $(TARGETS)

# ------------------------------------------------
# C 源文件编译和链接的模式规则
# 目标：生成可执行文件 (例如：app1)
# 依赖：对应的 .c 源文件 (例如：app1.c)
# ------------------------------------------------
%: %.cpp 
# 在执行编译/链接前，使用 shell 命令确保 BUILD_DIR 存在
	@$(MKDIR_P) $(BUILD_DIR) 
# 增加了 $(LDLIBS)
	$(CC) $(CFLAGS) $< -o $@ $(LDLIBS)

# ------------------------------------------------
# C++ 源文件编译和链接的模式规则
# 目标：生成可执行文件 (例如：app2)
# 依赖：对应的 .cpp 源文件 (例如：app2.cpp)
# ------------------------------------------------
%: %.cpp 
# 在执行编译/链接前，使用 shell 命令确保 BUILD_DIR 存在
	@$(MKDIR_P) $(BUILD_DIR)
# 增加了 $(LDLIBS)
	$(CC) $(CFLAGS) $< -o $@ $(LDLIBS)
	./$@

# ------------------------------------------------
# 如果你有很多共享的 .o 文件（例如 utils.o）需要链接，
# 并且你想将它们放在 BUILD_DIR 中，需要以下规则：
# 注意：在这种“单文件生成可执行文件”的模式下，通常将共享文件放在根目录更简单。
# ------------------------------------------------

# 确保 build 目录存在（但在这个场景下，我们在编译规则中使用了 @$(MKDIR_P)）
# 此目标可以保留，但不作为 all 的依赖
$(BUILD_DIR):
	$(MKDIR_P) $(BUILD_DIR)

.PHONY: all clean
clean:
# 清理所有生成的可执行文件，以及可能的 .o 文件和 build 目录
# 如果你使用了公共目标文件 (COMMON_OBJS)，还需要清理它们
# 	-rm -f $(COMMON_OBJS)
	-rm -rf $(BUILD_DIR)
